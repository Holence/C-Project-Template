# Copyright (C) 2025 Holence <Holence08@gmail.com>

# project struture:
# .
# ├── include
# │   └── config
# │   │   ├── auto.conf
# │   │   └── auto.conf.cmd
# │   └── generated
# │       ├── autoconf.h
# │       └── rustc_cfg
# ├── .config
# ├── Kconfig
# ├── Makefile
# └── scripts
#     ├── build.mk
#     ├── kconfig-build.mk
#     ├── setting.mk
#     └── tools.mk

# get the realpath of current file (https://stackoverflow.com/a/18137056)
__mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
__mkfile_dir  := $(dir $(__mkfile_path))
include $(__mkfile_dir)/tools.mk

################################
#        Custom Config         #
################################

##### Config for Verbose #####
V ?=
ifneq ($(findstring 1, $V),)
  Q =
else
  Q = @
endif

##### Config for Build #####
# the name of TARGET
# default value: main
NAME ?= main

# all the source files (.s, .S, .c, .cpp)
# will be compiled into object files using compiler, see "Recipes"
# default value: all srcs under current working directory, including symlinked folders
SRCS ?= $(call find_srcs, ., -follow)
# translate to relative path, and remove duplicated
SRCS := $(sort $(foreach __file,$(SRCS),$(shell realpath --no-symlinks --relative-to . $(__file))))
ifneq ($(findstring ../, $(SRCS)),)
$(call colored_warning,SRCS: $(SRCS))
$(call colored_error,SRCS contain file outside current dir$(comma) this is not acceptable)
endif

# the building dir
# default value: ./build/$(NAME)
# note: Add another subfolder $(NAME) is just a conservative way to
#       prevent mixing of built files (in some rare cases, a makefile
#       is used to build multiple target by changing $(NAME)). If you
#       only have one build target, you can simply define
#       BUILD_DIR := ./build
BUILD_DIR ?= ./build/$(NAME)

# all the dirs for searching header files
# will be used as -I flags for compiling
# default value: all dirs under current working directory, excluding build, including symlinked folders
INC_DIRS ?= $(shell find . -type d -path '*build' -prune -or -type d -follow -print)

##### Config for Build LIB #####
STATIC ?=
SHARED ?=

##### Config for Install #####
# To install to your system  

# default install location:
# - TARGET_EXEC -> $(INSTALL_DESTDIR)$(INSTALL_PREFIX)/bin/
# - TARGET_LIB_STATIC -> $(INSTALL_DESTDIR)$(INSTALL_PREFIX)/lib/
# - TARGET_LIB_SHARED -> $(INSTALL_DESTDIR)$(INSTALL_PREFIX)/lib/
# - each file/folder in INSTALL_HEADERS -> $(INSTALL_DESTDIR)$(INSTALL_PREFIX)/include/*
# 
# $(INSTALL_DESTDIR)$(INSTALL_PREFIX) default to /usr/local
#   you can change INSTALL_DESTDIR, such as /tmp
#   thus $(INSTALL_DESTDIR)$(INSTALL_PREFIX) will be /tmp/usr/local
INSTALL_DESTDIR ?=
INSTALL_PREFIX  ?= /usr/local
INSTALL_DIR     = $(INSTALL_DESTDIR)$(INSTALL_PREFIX)
ifneq ($(wildcard include),)
INSTALL_HEADERS ?= $(shell find include -mindepth 1 -maxdepth 1 -not \( -path 'include/config' -o -path 'include/generated' \))
else
INSTALL_HEADERS ?=
endif

##### Config for Kconfig Tool #####
# build kconfig tools from linux source code
#   `make config` and `make menuconfig`
#   - linux/scripts/basic/fixdep
#   - linux/scripts/kconfig/conf
#   - linux/scripts/kconfig/mconf
# then add them to $PATH
#   for example `ln -s` to `/usr/local/bin`
CONF   ?= conf
MCONF  ?= mconf
FIXDEP ?= fixdep

################################
#        Generated Vars        #
################################
# Generated Vars using Custom Config
# NAME -> TARGET
# SRCS -> OBJS
# INC_DIRS -> INC_FLAGS

# the TARGET
## build executable file only if STATIC && SHARED not set
ifeq ($(STATIC)$(SHARED),)
TARGET_EXEC = $(BUILD_DIR)/$(NAME)
endif
## build static library (archive file) if STATIC=1
ifeq ($(STATIC),1)
TARGET_LIB_STATIC = $(BUILD_DIR)/lib$(NAME).a
endif
## build dynamic library (shared object file) if SHARED=1
ifeq ($(SHARED),1)
TARGET_LIB_SHARED = $(BUILD_DIR)/lib$(NAME).so
endif

# Prepends BUILD_DIR and appends .o to every src file
# As an example, ./your_dir/hello.cpp turns into BUILD_DIR/./your_dir/hello.cpp.o
OBJS = $(SRCS:%=$(BUILD_DIR)/%.o)

# Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag
INC_FLAGS += $(addprefix -I,$(INC_DIRS))

# Include variables generated by menuconfig
-include include/config/auto.conf

################################
#            Flags             #
################################
# Variables Names Convention
# https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html

# Note: Later flags will override earlier ones. Thus, 
# if user assign flags in Makefile then include build.mk,
# we should append them in the end.

# C PreProcessor Flags
# The -MMD and -MP flags will let gcc generate .d files
# which will be used by Makefile (see `-include $(DEPS)`)
__CPPFLAGS :=
__CPPFLAGS += $(INC_FLAGS)
__CPPFLAGS += -MMD -MP

# C Compiler Flags
__CFLAGS :=
## warning option
__CFLAGS += -Wall -Werror -Wextra -Wpedantic
__CFLAGS += -Wno-unused-function -Wno-unused-parameter
__CFLAGS += -Wno-format
__CFLAGS += -Wstrict-aliasing -Wstrict-overflow
## compile option
__CFLAGS += $(CONFIG_CC_OPT)
__CFLAGS += $(if $(CONFIG_CC_LTO),-flto=auto)
__CFLAGS += $(if $(CONFIG_CC_DEBUG),-Og -ggdb3)
__CFLAGS += $(if $(CONFIG_CC_ANALYZER),-fanalyzer)

# Sanitizer
__SAN_FLAGS :=
__SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_UNDEFINED),-fsanitize=undefined)
__SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_ADDRESS),-fsanitize=address) # don't use this with valgrind
__SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_LEAK),-fsanitize=leak) # don't use this with valgrind
__SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_THREAD),-fsanitize=thread) # can't be combined with -fsanitize=address, -fsanitize=leak

# CXX Compiler Flags
__CXXFLAGS := $(__CFLAGS)

# Linker Flags
__LDFLAGS :=
__LDFLAGS += $(if $(CONFIG_CC_LTO),-flto=auto)
# __LDFLAGS += -Wl,-Map=output.map

# if building .so
ifeq ($(SHARED),1)
__CFLAGS  += -fPIC
__LDFLAGS += -shared
endif

# Sanitizer flags should be passed into both compiler and linker
SAN_FLAGS := $(__SAN_FLAGS) $(SAN_FLAGS) 
__CFLAGS  += $(SAN_FLAGS)
__LDFLAGS += $(SAN_FLAGS)

CPPFLAGS := $(__CPPFLAGS) $(CPPFLAGS)
CFLAGS   := $(__CFLAGS) $(CFLAGS)
CXXFLAGS := $(__CXXFLAGS) $(CXXFLAGS)
LDFLAGS  := $(__LDFLAGS) $(LDFLAGS)

# strip extra spaces
CPPFLAGS := $(strip $(CPPFLAGS))
CFLAGS   := $(strip $(CFLAGS))
CXXFLAGS := $(strip $(CXXFLAGS))
LDFLAGS  := $(strip $(LDFLAGS))

################################
#   Kconfig Related Function   #
################################
# mostly copied from linux/scripts/Kbuild.include

# Check if both commands are the same including their order. Result is empty
# string if equal.
cmd-check = $(filter-out $(subst $(space),$(space_escape),$(strip $(savedcmd_$@))), \
                         $(subst $(space),$(space_escape),$(strip $($1_cmd))))

# Replace >$< with >$$< to preserve $ when reloading the .cmd file
# (needed for make)
# Replace >#< with >$(pound)< to avoid starting a comment in the .cmd file
# (needed for make)
# Replace >'< with >'\''< to be able to enclose the whole string in '...'
# (needed for the shell)
make-cmd = $(call escsq,$(subst $(pound),$$(pound),$(subst $$,$$$$,$(1))))

# Find any prerequisites that are newer than target or that do not exist.
# PHONY targets skipped in both cases.
# If there is no prerequisite other than phony targets, $(newer-prereqs) becomes
# empty even if the target does not exist. cmd-check saves this corner case.
newer-prereqs = $(filter-out $(PHONY),$?)

# It is a typical mistake to forget the FORCE prerequisite. Check it here so
# no more breakage will slip in.
check-FORCE = $(if $(filter FORCE, $^),,$(warning FORCE prerequisite is missing))

ifneq ($(findstring 2, $V),)
# tell why a target got built
_why =                                                                \
    $(if $(filter $@, $(PHONY)),? due to target is PHONY,             \
        $(if $(wildcard $@),                                          \
            $(if $(newer-prereqs),? due to newer: $(newer-prereqs),   \
                $(if $(cmd-check),                                    \
                    $(if $(savedcmd_$@),? due to command line change $(newline) $(strip $(savedcmd_$@)) $(newline) $(strip $($1_cmd)) , \
                        ? due to dep missing ($(@:.o=.d))             \
                    )                                                 \
                )                                                     \
            ),                                                        \
            ? due to target missing ($@)                              \
        )                                                             \
    )

explain_why_rebuild = @echo "  $(strip $(_why))"
else
explain_why_rebuild =
endif

# call run_fixdep(dep_file, obj_file, cmd) after .o and .d are generated by compiler
# 
# fixdep will (source code at linux/scripts/basic/fixdep.c)
# - record your compile command as "savedcmd_path/to/xxx.o=..."
# - look for "CONFIG_XXX" from src_file (.h, .c files is mentioned in dep_file,
#   which contains CONFIG_XXX), then add "include/config/XXX" to dependency
# - print out the fixed-dependency
# 
# finally use mv to overwite the .d file
#
# Also a silly note on `fixdep ... > tmp && mv tmp ...`
# you can't do `print_modified_version a.txt > a.txt`
# because the redirection `> a.txt` is set up before `print_modified_version` runs
# you can only write to a temp file, then overwrite the origin one
define run_fixdep
	@$(FIXDEP) $1 $2 '$(call make-cmd, $3)' > $1.tmp
	@mv $1.tmp $1
endef

# if_changed_then_compile(rule)
#   rule is something like cc_o_s, cc_o_c or cxx_o_cpp (they are defined in Recipes)
#   call with $(call if_changed_then_compile,rule)
#   there is no space between the "," and "rule"! or $($1_cmd) will not work!
# check if any of $(newer-prereqs) $(cmd-check) $(check-FORCE) is not empty
#   if so, then perform compile:
#     1. mkdir
#     2. echo $(rule_log)
#     3. if $V has 2, then explain_why_rebuild
#     4. run $(rule_cmd)
#     5. run fixdep
#     6. if $(CONFIG_GENERATE_PREPROCESSED), then
#          echo $(rule_preprocessor_log)
#          run $(rule_preprocessor_cmd)
define if_changed_then_compile
	$(if $(newer-prereqs)$(cmd-check)$(check-FORCE),
		$(Q)mkdir -p $(dir $@)
		$($1_log)
		$(explain_why_rebuild)
		$(Q)$($1_cmd)
		$(call run_fixdep, $(@:.o=.d), $@, $($1_cmd))
		$(if $(CONFIG_GENERATE_PREPROCESSED),
			$($1_preprocessor_log)
			$(Q)$($1_preprocessor_cmd)
		)
	)
endef

################################
#           Recipes            #
################################

FORCE:
PHONY += FORCE

##### DEPS #####

# As an example, BUILD_DIR/hello.cpp.o turns into BUILD_DIR/hello.cpp.d
DEPS = $(OBJS:.o=.d)
# Let make knows which .o depend on which .o / .h
-include $(DEPS)

##### Compile #####

# Compile Pure Assembly into Object File
as_o_S_log = @echo "+ AS $< -> $@"
as_o_S_cmd = $(AS) $(ASFLAGS) -c $< -o $@
$(BUILD_DIR)/%.s.o: %.s
	$(Q)mkdir -p $(dir $@)
	$(as_o_S_log)
	$(Q)$(as_o_S_cmd)

# Compile Preprocessed Assembly into Object File
cc_o_s_log = @echo "+ CC $< -> $@"
cc_o_s_cmd = $(CC) $(CPPFLAGS) $(ASFLAGS) -c $< -o $@
cc_o_s_preprocessor_log = @echo "+ CC $< -> $(@:.o=.i)"
cc_o_s_preprocessor_cmd = $(CC) $(CPPFLAGS) $(ASFLAGS) -E -MF /dev/null $< | grep -ve '^\#' | clang-format - > $(@:.o=.i)
$(BUILD_DIR)/%.S.o: %.S FORCE
	$(call if_changed_then_compile,cc_o_s)

# Compile C source into Object File
cc_o_c_log = @echo "+ CC $< -> $@"
cc_o_c_cmd = $(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
cc_o_c_preprocessor_log = @echo "+ CC $< -> $(@:.o=.i)"
cc_o_c_preprocessor_cmd = $(CC) $(CPPFLAGS) $(CFLAGS) -E -MF /dev/null $< | grep -ve '^\#' | clang-format - > $(@:.o=.i)
$(BUILD_DIR)/%.c.o: %.c FORCE
	$(call if_changed_then_compile,cc_o_c)

# Compile C++ source into Object File
cxx_o_cpp_log = @echo "+ CXX $< -> $@"
cxx_o_cpp_cmd = $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@
cxx_o_cpp_preprocessor_log = @echo "+ CXX $< -> $(@:.o=.i)"
cxx_o_cpp_preprocessor_cmd = $(CXX) $(CPPFLAGS) $(CXXFLAGS) -E -MF /dev/null $< | grep -ve '^\#' | clang-format - > $(@:.o=.i)
$(BUILD_DIR)/%.cpp.o: %.cpp FORCE
	$(call if_changed_then_compile,cxx_o_cpp)

##### Link #####

# If LDFLAGS changed, by default make won't auto re-make. Thus borrowing
# the idea from ​​fixdep (record the command for compiling object files and
# FORCE check whether it's changed), we also record the LDFLAGS to a file
# and FORCE check whether the LDFLAGS is different from the recorded one.
SAVED_LDFLAGS = $(BUILD_DIR)/.saved_ldflags
# Update the .saved_ldflags file whenever LDFLAGS changes
$(SAVED_LDFLAGS): FORCE
	$(Q)mkdir -p $(dir $@)
	@echo "$(LDFLAGS)" | cmp -s - $@ || echo "$(LDFLAGS)" > $@

# Link all Object Files into TARGET_EXEC or TARGET_LIB_SHARED
link_log = @$(call print_ansi_fg_green,+ Link $@)
link_cmd = $(CXX) $(OBJS) -o $@ $(LDFLAGS)
$(TARGET_EXEC) $(TARGET_LIB_SHARED): $(OBJS) $(SAVED_LDFLAGS)
	$(link_log)
	$(Q)$(link_cmd)

##### Archive #####

# Archive all Object Files into TARGET_LIB_STATIC
archive_log = @$(call print_ansi_fg_green,+ AR $@)
archive_cmd = $(AR) rcs $@ $^
$(TARGET_LIB_STATIC): $(OBJS)
	$(archive_log)
	$(Q)$(archive_cmd)

################################
#            Target            #
################################

# Include recipes generated by menuconfig
-include include/config/auto.conf.cmd

# mconf will create and edit .config
menuconfig:
	$(MCONF) Kconfig
	$(CONF) --syncconfig Kconfig
PHONY += menuconfig

__kconfig_auto_generated = include/config/auto.conf include/config/auto.conf.cmd include/generated/autoconf.h include/generated/rustc_cfg

# if .config is newer than $(__kconfig_auto_generated)
# then update them using `conf --syncconfig`
#
#   mconf will only create $(__kconfig_auto_generated) if they
#   don't exist. we need to use `conf --syncconfig` to update
#   them if they are older than .config
#   (see source code in mconf.c and conf.c)
#   
#   also, because two of these files are include as Makefile
#     - include/config/auto.conf
#     - include/config/auto.conf.cmd
#   make will automatically check if these two should be re-make
#     - make include/config/auto.conf
#     - make include/config/auto.conf.cmd
#   but `conf --syncconfig` update all of them at once, so there
#   will be one redundant re-make. so we better check timestamp
#   manually!
$(__kconfig_auto_generated): .config
	@if test $< -nt $@; then \
		echo $(CONF) --syncconfig Kconfig; \
		$(CONF) --syncconfig Kconfig; \
	fi

.DEFAULT_GOAL = all
all: $(TARGET_EXEC) $(TARGET_LIB_STATIC) $(TARGET_LIB_SHARED)
PHONY += all

run: $(TARGET_EXEC)
	$(Q)$(TARGET_EXEC) $(ARGS)
PHONY += run

gdb: $(TARGET_EXEC)
	gdb $(TARGET_EXEC)
PHONY += gdb

valgrind: $(TARGET_EXEC)
	$(call run_valgrind, $(TARGET_EXEC))
PHONY += valgrind

# clean build dir
clean::
	$(call logged_rm,$(BUILD_DIR))
PHONY += clean

# clean kconfig related files
clean-config:
	$(call logged_rm,include/generated include/config .config .config.old)
PHONY += clean-config

# all clean targets
clean-all:: clean clean-config
PHONY += clean-all

# __install(file_path,dst_dir,permission_mode)
# 1. create dst_dir if not exist
# 2. copy file from file_path to dst_dir and chmod permission_mode
define __install
	$(Q)install -d $2
	$(Q)install -m$3 $1 $2
	@$(call print_ansi_fg_green,+ Install $$(ls $2$(notdir $1)))
endef

# Install to system
# - /usr/local/bin/$(TARGET_EXEC)
# - /usr/local/lib/$(TARGET_LIB_STATIC)
# - /usr/local/lib/$(TARGET_LIB_SHARED)
# - each file/folder in INSTALL_HEADERS to /usr/local/include/*
install: all
ifneq ($(TARGET_EXEC),)
	$(call __install,$(TARGET_EXEC),$(INSTALL_DIR)/bin/,755)
endif
ifneq ($(TARGET_LIB_STATIC),)
	$(call __install,$(TARGET_LIB_STATIC),$(INSTALL_DIR)/lib/,644)
endif
ifneq ($(TARGET_LIB_SHARED),)
	$(call __install,$(TARGET_LIB_SHARED),$(INSTALL_DIR)/lib/,644)
	ldconfig
endif
ifneq ($(TARGET_LIB_STATIC)$(TARGET_LIB_SHARED),)
	$(foreach __file,$(shell find $(INSTALL_HEADERS) -type f),\
		$(call __install,$(__file),$(dir $(INSTALL_DIR)/$(__file)),644)$(newline)\
	)
endif
PHONY += install

# Remove installed files
# - /usr/local/bin/$(TARGET_EXEC)
# - /usr/local/lib/$(TARGET_LIB_STATIC)
# - /usr/local/lib/$(TARGET_LIB_SHARED)
# - each file/folder in INSTALL_HEADERS in /usr/local/include/*
uninstall:
ifneq ($(TARGET_EXEC),)
	$(call logged_rm,$(INSTALL_DIR)/bin/$(notdir $(TARGET_EXEC)))
endif
ifneq ($(TARGET_LIB_STATIC),)
	$(call logged_rm,$(INSTALL_DIR)/lib/$(notdir $(TARGET_LIB_STATIC)))
endif
ifneq ($(TARGET_LIB_SHARED),)
	$(call logged_rm,$(INSTALL_DIR)/lib/$(notdir $(TARGET_LIB_SHARED)))
	ldconfig
endif
ifneq ($(TARGET_LIB_STATIC)$(TARGET_LIB_SHARED),)
	$(foreach __file,$(INSTALL_HEADERS),\
		$(call logged_rm,$(INSTALL_DIR)/$(__file)$(newline))\
	)
endif
PHONY += uninstall

help::
	@echo 'Main Targets:'
	@echo '    menuconfig   - edit kconfig'
	@echo '    all          - build all (default target)'
	@echo '                   build TARGET_EXEC if STATIC && SHARED not set (default)'
	@echo '                   build TARGET_LIB_STATIC if STATIC=1'
	@echo '                   build TARGET_LIB_SHARED if SHARED=1'
	@echo '    run          - build TARGET_EXEC and run'
	@echo '    gdb          - build TARGET_EXEC and run gdb'
	@echo '    valgrind     - build TARGET_EXEC and run valgrind'
	@echo 'Install Targets:'
	@echo '    install      - install to system'
	@echo '                   install TARGET_EXEC if STATIC && SHARED not set (default)'
	@echo '                       default location: /usr/local/bin/'
	@echo '                   install TARGET_LIB_STATIC if STATIC=1'
	@echo '                       default location: /usr/local/lib/'
	@echo '                   install TARGET_LIB_SHARED if SHARED=1'
	@echo '                       default location: /usr/local/lib/'
	@echo '                   install each file/folder in INSTALL_HEADERS if STATIC || SHARED is set'
	@echo '                       default location: /usr/local/include/*'
	@echo '                       default INSTALL_HEADERS: each file/folder in ./include/, excluding'
	@echo '                                                include/config and include/generated'
	@echo '    uninstall    - remove installed files'
	@echo ''
	@echo '    Note: These targets require root permissions!'
	@echo '          And `ldconfig` is automatically called after install/uninstall SHARED lib'
	@echo 'Others:'
	@echo '    clean        - clean build dir'
	@echo '    clean-config - clean kconfig related files'
	@echo '    clean-all    - run all clean targets'
	@echo '    help         - show help text'
	@echo 'Variables:'
	@echo '    make V=n     - verbose'
	@echo '                   V=1: verbose build'
	@echo '                   V=2: give reason for rebuild of target'
	@echo '                   V=1 and V=2 can be combined with V=12'
PHONY += help

# Declare the contents of the PHONY variable as phony.  We keep that
# information in a variable so we can use it in if_changed and friends.
.PHONY: $(PHONY)

ifneq ($(findstring 1, $V),)
$(call colored_info,$(ANSI_FG_BLACK),================= Custom Config ==================)
$(call colored_info,$(ANSI_FG_BLACK),--------------- Config for Build -----------------)
$(call colored_info,$(ANSI_FG_BLACK),NAME      : $(NAME))
$(call colored_info,$(ANSI_FG_BLACK),SRCS      : $(SRCS))
$(call colored_info,$(ANSI_FG_BLACK),BUILD_DIR : $(BUILD_DIR))
$(call colored_info,$(ANSI_FG_BLACK),INC_DIRS  : $(INC_DIRS))
$(call colored_info,$(ANSI_FG_BLACK),--------------- Config for Build LIB -------------)
$(call colored_info,$(ANSI_FG_BLACK),STATIC : $(STATIC))
$(call colored_info,$(ANSI_FG_BLACK),SHARED : $(SHARED))
$(call colored_info,$(ANSI_FG_BLACK),--------------- Config for Install ---------------)
$(call colored_info,$(ANSI_FG_BLACK),INSTALL_DESTDIR    : $(INSTALL_DESTDIR))
$(call colored_info,$(ANSI_FG_BLACK),INSTALL_PREFIX     : $(INSTALL_PREFIX))
$(call colored_info,$(ANSI_FG_BLACK),INSTALL_DIR        : $(INSTALL_DIR))
$(call colored_info,$(ANSI_FG_BLACK),INSTALL_HEADERS    : $(INSTALL_HEADERS))
$(call colored_info,$(ANSI_FG_BLACK),------------- Config for Kconfig Tool ------------)
$(call colored_info,$(ANSI_FG_BLACK),CONF   : $(CONF))
$(call colored_info,$(ANSI_FG_BLACK),MCONF  : $(MCONF))
$(call colored_info,$(ANSI_FG_BLACK),FIXDEP : $(FIXDEP))
$(call colored_info,$(ANSI_FG_BLACK),================= Generated Vars =================)
$(call colored_info,$(ANSI_FG_BLACK),TARGET_EXEC       : $(TARGET_EXEC))
$(call colored_info,$(ANSI_FG_BLACK),TARGET_LIB_STATIC : $(TARGET_LIB_STATIC))
$(call colored_info,$(ANSI_FG_BLACK),TARGET_LIB_SHARED : $(TARGET_LIB_SHARED))
$(call colored_info,$(ANSI_FG_BLACK),OBJS              : $(OBJS))
$(call colored_info,$(ANSI_FG_BLACK),INC_FLAGS         : $(INC_FLAGS))
$(call colored_info,$(ANSI_FG_BLACK),================ Common variables ================)
$(call colored_info,$(ANSI_FG_BLACK),AS  : $(AS))
$(call colored_info,$(ANSI_FG_BLACK),CC  : $(CC))
$(call colored_info,$(ANSI_FG_BLACK),CXX : $(CXX))
$(call colored_info,$(ANSI_FG_BLACK),AR  : $(AR))
$(call colored_info,$(ANSI_FG_BLACK),RM  : $(RM))
$(call colored_info,$(ANSI_FG_BLACK),====================== Flags =====================)
$(call colored_info,$(ANSI_FG_BLACK),CPPFLAGS : $(CPPFLAGS))
$(call colored_info,$(ANSI_FG_BLACK),CFLAGS   : $(CFLAGS))
$(call colored_info,$(ANSI_FG_BLACK),CXXFLAGS : $(CXXFLAGS))
$(call colored_info,$(ANSI_FG_BLACK),LDFLAGS  : $(LDFLAGS))
$(call colored_info,$(ANSI_FG_BLACK),====================== DEPS ======================)
$(call colored_info,$(ANSI_FG_BLACK),DEPS : $(DEPS))
endif

# if not running `make clean...` or `make help` or `make menuconfig` or `make uninstall`
#   and if .config does not exist
#     then quit
ifeq ($(findstring clean,$(MAKECMDGOALS))$(filter help menuconfig uninstall,$(MAKECMDGOALS)),)
ifeq ($(wildcard .config),)
$(call colored_warning,WARNING: .config does not exist!)
$(call colored_error,To build the project$(comma) first run 'make menuconfig')
endif
endif
