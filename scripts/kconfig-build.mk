# TODO "Final Binary File" could be .so or .a

# project struture:
# .
# ├── include
# │   └── config
# │   │   ├── auto.conf
# │   │   └── auto.conf.cmd
# │   └── generated
# │       ├── autoconf.h
# │       └── rustc_cfg
# ├── .config
# ├── Kconfig
# ├── Makefile
# └── scripts
#     ├── build.mk
#     ├── color.mk
#     ├── kconfig-build.mk
#     ├── setting.mk
#     └── tools.mk

# get the realpath of current file (https://stackoverflow.com/a/18137056)
__mkfile_path := $(abspath $(lastword $(MAKEFILE_LIST)))
__mkfile_dir  := $(dir $(__mkfile_path))
include $(__mkfile_dir)/tools.mk
include $(__mkfile_dir)/color.mk

################################
#        Custom Config         #
################################

ifneq ($(findstring 1, $V),)
  Q =
else
  Q = @
endif

# the name of "Final Binary File"
# default value: main.out
NAME ?= main.out

# all the source files (.s, .S, .c, .cpp)
# will be compiled into object files using compiler, see "Recipes"
# default value: all srcs under current working directory
SRCS ?= $(call find_srcs, .)

# the build dir
# default value: ./build
BUILD_DIR ?= ./build

# all dirs for searching header files
# will be used as -I flags for compiling
# default value: all dirs under current working directory
INC_DIRS ?= $(call find_dirs, .)

# build kconfig tools from linux source code
#   `make config` and `make menuconfig`
#   - linux/scripts/basic/fixdep
#   - linux/scripts/kconfig/conf
#   - linux/scripts/kconfig/mconf
# then add them to $PATH
#   for example `ln -s` to `/usr/local/bin`
CONF   ?= conf
MCONF  ?= mconf
FIXDEP ?= fixdep

################################
#        Generated Vars        #
################################
# Generated Vars using Custom Config
# NAME -> BINARY
# SRCS -> OBJS
# INC_DIRS -> INC_FLAGS

# the "Final Binary File"
BINARY = $(BUILD_DIR)/$(NAME)

# Prepends BUILD_DIR and appends .o to every src file
# As an example, ./your_dir/hello.cpp turns into BUILD_DIR/./your_dir/hello.cpp.o
OBJS = $(SRCS:%=$(BUILD_DIR)/%.o)

# Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag
INC_FLAGS = $(addprefix -I,$(INC_DIRS))

# Include variables generated by menuconfig
-include include/config/auto.conf

################################
#            Flags             #
################################
# Variables Names Convention
# https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html

# C PreProcessor Flags
# The -MMD and -MP flags will let gcc generate .d files
# which will be used by Makefile (see `-include $(DEPS)`)
CPPFLAGS = $(INC_FLAGS) -MMD -MP

# C Compiler Flags
## warning option
CFLAGS += -Wall -Werror -Wextra -Wpedantic
CFLAGS += -Wno-unused-function -Wno-unused-parameter
CFLAGS += -Wno-format
CFLAGS += -Wstrict-aliasing=2 -Wstrict-overflow=5

## compile option
CFLAGS += $(CONFIG_CC_OPT)
CFLAGS += $(if $(CONFIG_CC_LTO),-flto)
CFLAGS += $(if $(CONFIG_CC_DEBUG),-Og -ggdb3)
CFLAGS += $(if $(CONFIG_CC_ANALYZER),-fanalyzer)
# CFLAGS += -fdata-sections -ffunction-sections

## Sanitizers
SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_UNDEFINED),-fsanitize=undefined)
SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_ADDRESS),-fsanitize=address) # don't use this with valgrind
SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_LEAK),-fsanitize=leak) # don't use this with valgrind
SAN_FLAGS += $(if $(CONFIG_CC_SANITIZE_THREAD),-fsanitize=thread) # can't be combined with -fsanitize=address, -fsanitize=leak
CFLAGS += $(SAN_FLAGS)

# TODO: CXX Compiler Flags

# Linker Flags
LDFLAGS += $(SAN_FLAGS)
LDFLAGS += $(if $(CONFIG_CC_LTO),-flto)
LDFLAGS += -Wl,--gc-sections
# LDFLAGS += -Wl,-Map=output.map

################################
#   Kconfig Related Function   #
################################
# mostly copied from linux/scripts/Kbuild.include

# Check if both commands are the same including their order. Result is empty
# string if equal.
cmd-check = $(filter-out $(subst $(space),$(space_escape),$(strip $(savedcmd_$@))), \
                         $(subst $(space),$(space_escape),$(strip $($1_cmd))))

# Replace >$< with >$$< to preserve $ when reloading the .cmd file
# (needed for make)
# Replace >#< with >$(pound)< to avoid starting a comment in the .cmd file
# (needed for make)
# Replace >'< with >'\''< to be able to enclose the whole string in '...'
# (needed for the shell)
make-cmd = $(call escsq,$(subst $(pound),$$(pound),$(subst $$,$$$$,$(1))))

# Find any prerequisites that are newer than target or that do not exist.
# PHONY targets skipped in both cases.
# If there is no prerequisite other than phony targets, $(newer-prereqs) becomes
# empty even if the target does not exist. cmd-check saves this corner case.
newer-prereqs = $(filter-out $(PHONY),$?)

# It is a typical mistake to forget the FORCE prerequisite. Check it here so
# no more breakage will slip in.
check-FORCE = $(if $(filter FORCE, $^),,$(warning FORCE prerequisite is missing))

ifneq ($(findstring 2, $V),)
# tell why a target got built
_why =                                                                \
    $(if $(filter $@, $(PHONY)),? due to target is PHONY,             \
        $(if $(wildcard $@),                                          \
            $(if $(newer-prereqs),? due to newer: $(newer-prereqs),   \
                $(if $(cmd-check),                                    \
                    $(if $(savedcmd_$@),? due to command line change, \
                        ? due to dep missing ($(@:.o=.d))             \
                    )                                                 \
                )                                                     \
            ),                                                        \
            ? due to target missing ($@)                              \
        )                                                             \
    )

explain_why_rebuild = @echo "  $(strip $(_why))"
else
explain_why_rebuild =
endif

# call run_fixdep(dep_file, obj_file, cmd) after .o and .d are generated by compiler
# 
# fixdep will (source code at linux/scripts/basic/fixdep.c)
# - record your compile command as "savedcmd_path/to/xxx.o=..."
# - look for "CONFIG_XXX" from src_file (.h, .c files is mentioned in dep_file,
#   which contains CONFIG_XXX), then add "include/config/XXX" to dependency
# - print out the fixed-dependency
# 
# finally use mv to overwite the .d file
#
# Also a silly note on `fixdep ... > tmp && mv tmp ...`
# you can't do `print_modified_version a.txt > a.txt`
# because the redirection `> a.txt` is set up before `print_modified_version` runs
# you can only write to a temp file, then overwrite the origin one
define run_fixdep
	@$(FIXDEP) $1 $2 '$(call make-cmd, $3)' > $1.tmp
	@mv $1.tmp $1
endef

# if_changed_then_compile(rule)
#   rule is something like cc_o_s, cc_o_c or cxx_o_cpp (they are defined in Recipes)
#   call with $(call if_changed_then_compile,rule)
#   there is no space between the "," and "rule"! or $($1_cmd) will not work!
# check if any of $(newer-prereqs) $(cmd-check) $(check-FORCE) is not empty
#   if so, then perform compile:
#     1. mkdir
#     2. echo $(rule_log)
#     3. if $V has 2, then explain_why_rebuild
#     4. run $(rule_cmd)
#     5. run fixdep
#     6. if $(CONFIG_GENERATE_PREPROCESSED), then
#          echo $(rule_preprocessor_log)
#          run $(rule_preprocessor_cmd)
define if_changed_then_compile
	$(if $(newer-prereqs)$(cmd-check)$(check-FORCE),
		$(Q)mkdir -p $(dir $@)
		$($1_log)
		$(explain_why_rebuild)
		$(Q)$($1_cmd)
		$(call run_fixdep, $(@:.o=.d), $@, $($1_cmd))
		$(if $(CONFIG_GENERATE_PREPROCESSED),
			$($1_preprocessor_log)
			$(Q)$($1_preprocessor_cmd)
		)
	)
endef

################################
#           Recipes            #
################################

# As an example, BUILD_DIR/hello.cpp.o turns into BUILD_DIR/hello.cpp.d
DEPS     := $(OBJS:.o=.d)
# Let make knows which .o depend on which .o / .h
-include $(DEPS)

# Compile Pure Assembly into Object File
as_o_S_log = @echo "+ AS $< -> $@"
as_o_S_cmd = $(AS) $(ASFLAGS) -c $< -o $@
$(BUILD_DIR)/%.s.o: %.s
	$(Q)mkdir -p $(dir $@)
	$(as_o_S_log)
	$(as_o_S_cmd)

# Compile Preprocessed Assembly into Object File
cc_o_s_log = @echo "+ CC $< -> $@"
cc_o_s_cmd = $(CC) $(CPPFLAGS) $(ASFLAGS) -c $< -o $@
cc_o_s_preprocessor_log = @echo "+ CC $< -> $(@:.o=.i)"
cc_o_s_preprocessor_cmd = $(CC) $(CPPFLAGS) $(ASFLAGS) -E -MF /dev/null $< | grep -ve '^\#' | clang-format - > $(@:.o=.i)
$(BUILD_DIR)/%.S.o: %.S FORCE
	$(call if_changed_then_compile,cc_o_s)

# Compile C source into Object File
cc_o_c_log = @echo "+ CC $< -> $@"
cc_o_c_cmd = $(CC) $(CPPFLAGS) $(CFLAGS) -c $< -o $@
cc_o_c_preprocessor_log = @echo "+ CC $< -> $(@:.o=.i)"
cc_o_c_preprocessor_cmd = $(CC) $(CPPFLAGS) $(CFLAGS) -E -MF /dev/null $< | grep -ve '^\#' | clang-format - > $(@:.o=.i)
$(BUILD_DIR)/%.c.o: %.c FORCE
	$(call if_changed_then_compile,cc_o_c)

# Compile C++ source into Object File
cxx_o_cpp_log = @echo "+ CXX $< -> $@"
cxx_o_cpp_cmd = $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $< -o $@
cxx_o_cpp_preprocessor_log = @echo "+ CXX $< -> $(@:.o=.i)"
cxx_o_cpp_preprocessor_cmd = $(CXX) $(CPPFLAGS) $(CXXFLAGS) -E -MF /dev/null $< | grep -ve '^\#' | clang-format - > $(@:.o=.i)
$(BUILD_DIR)/%.cpp.o: %.cpp FORCE
	$(call if_changed_then_compile,cxx_o_cpp)

# Link all Object Files into "Final Binary File"
link_log = @echo "+ Link $@"
link_cmd = $(CC) $^ -o $@ $(LDFLAGS)
$(BINARY): $(OBJS)
	$(link_log)
	$(Q)$(link_cmd)

FORCE:
PHONY += FORCE

################################
#            Rules             #
################################

# Include recipes generated by menuconfig
-include include/config/auto.conf.cmd
__kconfig_auto_generated = include/config/auto.conf include/config/auto.conf.cmd include/generated/autoconf.h include/generated/rustc_cfg

menuconfig:
# call mconf to produce .config and $(__kconfig_auto_generated)
	$(MCONF) Kconfig
# See source code in mconf.c and conf.c
# It calls `conf_write_autoconf(overwrite=0)` before exit,
# thus $(__kconfig_auto_generated) are only written if they
# don't exist. So here we need to call `conf --syncconfig`
# manually to force call `conf_write_autoconf(overwrite=1)`
	$(CONF) --syncconfig Kconfig
PHONY += menuconfig

# if .config is newer than $(__kconfig_auto_generated)
# then update them using `conf --syncconfig`
$(__kconfig_auto_generated): .config
	$(CONF) --syncconfig Kconfig

.DEFAULT_GOAL = app
app: $(BINARY)
PHONY += app

run: app
	@$(BINARY)
PHONY += run

memcheck: app
	$(call run_memcheck, $(BINARY))
PHONY += memcheck

clean:
	-$(RM) -r $(BUILD_DIR)
PHONY += clean

clean_config:
	-$(RM) -r include/generated include/config .config .config.old
PHONY += clean_config

clean_all: clean clean_config
PHONY += clean_all

help::
	@echo 'Main Targets:'
	@echo '    menuconfig       - edit kconfig'
	@echo '    app              - compile (default target)'
	@echo '    run              - compile and run'
	@echo '    memcheck         - compile and memcheck'
	@echo 'Others:'
	@echo '    clean            - clean build files'
	@echo '    clean_config     - clean kconfig files'
	@echo '    clean_all        - clean all files'
	@echo '    help             - show help text'
	@echo 'Variables:'
	@echo '    make V=n           1: verbose build'
	@echo '                       2: give reason for rebuild of target'
	@echo '                       V=1 and V=2 can be combined with V=12'
PHONY += help

# Declare the contents of the PHONY variable as phony.  We keep that
# information in a variable so we can use it in if_changed and friends.
.PHONY: $(PHONY)

ifneq ($(findstring 1, $V),)
$(call colored_print,$(ANSI_FG_BLACK),---------- Custom Config -----------)
$(call colored_print,$(ANSI_FG_BLACK),NAME      : $(NAME))
$(call colored_print,$(ANSI_FG_BLACK),SRCS      : $(SRCS))
$(call colored_print,$(ANSI_FG_BLACK),BUILD_DIR : $(BUILD_DIR))
$(call colored_print,$(ANSI_FG_BLACK),INC_DIRS  : $(INC_DIRS))
$(call colored_print,$(ANSI_FG_BLACK),CONF      : $(CONF))
$(call colored_print,$(ANSI_FG_BLACK),MCONF     : $(MCONF))
$(call colored_print,$(ANSI_FG_BLACK),FIXDEP    : $(FIXDEP))
$(call colored_print,$(ANSI_FG_BLACK),---------- Generated Vars ----------)
$(call colored_print,$(ANSI_FG_BLACK),BINARY    : $(BINARY))
$(call colored_print,$(ANSI_FG_BLACK),OBJS      : $(OBJS))
$(call colored_print,$(ANSI_FG_BLACK),INC_FLAGS : $(INC_FLAGS))
$(call colored_print,$(ANSI_FG_BLACK),--------- Common variables ---------)
$(call colored_print,$(ANSI_FG_BLACK),AS        : $(AS))
$(call colored_print,$(ANSI_FG_BLACK),CC        : $(CC))
$(call colored_print,$(ANSI_FG_BLACK),CXX       : $(CXX))
$(call colored_print,$(ANSI_FG_BLACK),RM        : $(RM))
$(call colored_print,$(ANSI_FG_BLACK),-------------- Flags ---------------)
$(call colored_print,$(ANSI_FG_BLACK),CPPFLAGS  : $(CPPFLAGS))
$(call colored_print,$(ANSI_FG_BLACK),CFLAGS    : $(CFLAGS))
$(call colored_print,$(ANSI_FG_BLACK),CXXFLAGS  : $(CXXFLAGS))
$(call colored_print,$(ANSI_FG_BLACK),LDFLAGS   : $(LDFLAGS))
$(call colored_print,$(ANSI_FG_BLACK),-------------- DEPS ----------------)
$(call colored_print,$(ANSI_FG_BLACK),DEPS      : $(DEPS))
endif

# if not running `make clean...` or `make help` or `make menuconfig`
#   and if .config does not exist
#     then quit
ifeq ($(findstring clean,$(MAKECMDGOALS))$(filter help menuconfig,$(MAKECMDGOALS)),)
ifeq ($(wildcard .config),)
$(call colored_warning,WARNING: .config does not exist!)
$(call colored_error,To build the project$(comma) first run 'make menuconfig')
endif
endif
